## 2018/12/09

### [118. Pascal's Triangle]() `Easy`

#### 原本的解法

> Runtime: 12 ms, faster than 22.06% of Swift online submissions for Pascal's Triangle.

很慢又要逐一初始化覺得很不合理！ 的解法

``` swift
class Solution {
    func generate(_ numRows: Int) -> [[Int]] {
        var result = [[Int]](repeating: [], count: numRows)
        for row in (0 ..< numRows) {
            let size = row + 1
            result[row] = [Int](repeating: 0, count: size)
            
            result[row][0] = 1
            result[row][row] = 1
            
            if row > 0 {
                for item in (1..<row) {
                    result[row][item] = result[row-1][item-1] + result[row-1][item]
                }   
            }
        }
        
        return result
    }
}
```

## 2018/12/08

### [66. Plus One](https://leetcode.com/problems/plus-one/submissions/) `Easy`

``` swift
class Solution {
    func plusOne(_ digits: [Int]) -> [Int] {
        var result = digits
        var shouldCarry = true
        
        for (index, item) in result.enumerated().reversed() {
            let addition = shouldCarry ? 1 : 0
            let sum = item + addition
            shouldCarry = (sum / 10) != 0
            result[index] = sum % 10
        }
        
        if shouldCarry {
            result.insert(1, at: 0)
        }
        
        return result
    }
}
```

接著想到不需要進位的時候應該是不需要做多餘的運算，所以應該可以改成這樣：

``` swift
class Solution {
    func plusOne(_ digits: [Int]) -> [Int] {
        var result = digits
        var shouldCarry = true
        
        for (index, item) in result.enumerated().reversed() {
            if shouldCarry {
                let sum = result[index] + 1
                shouldCarry = (sum / 10) != 0
                result[index] = sum % 10
            } else {
                shouldCarry = false
            }
        }
        
        if shouldCarry {
            result.insert(1, at: 0)
        }
        
        return result
    }
}
```


#### 碰到的速度上的問題

在反向走訪的地方
一開始沒有用 enumerated 的方式，會慢非常多 (執行時間 `28ms`)

``` swift
for index in (0..<result.count).reversed() {}
```

改成 enumerated 之後，執行速度就變快了 → (執行時間 `12ms`)

``` swift
for (index, item) in result.enumerated().reversed() {}
```

### [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/) `Medium`

``` swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        guard nums.count > 2 else { return nums.count }
        
        var latestPosition = 0
        var appeared = 0
        
        for index in 1..<nums.count {
            if nums[latestPosition] != nums[index] {
                latestPosition += 1
                nums[latestPosition] = nums[index]
                appeared = 0
            } else {
                appeared += 1
                if appeared < 2 {
                    latestPosition += 1
                    nums[latestPosition] = nums[index]
                }
            }
        }
        
        
        return latestPosition + 1
    }
}
```

#### 參考

- https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/discuss/27993/Swift-solution-Two-Pointers

## 2018/12/07

### [27. Remove Element](https://leetcode.com/problems/remove-element/) `Easy`

``` swift
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        guard nums.count > 0 else { return 0 }
        
        var latestPosition = 0
        for index in 0..<nums.count {
            if nums[index] != val {
                nums[latestPosition] = nums[index]
                latestPosition += 1
            }
        }
        
        return latestPosition 
    }
}
```

### [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) `Easy`

``` swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        guard nums.count > 0 else { return 0 }
        var latestPosition = 0
        for index in 0..<nums.count {
            if nums[index] != nums[latestPosition] {
                latestPosition += 1
                nums[latestPosition] = nums[index]
            }
        }
        return latestPosition + 1
    }
}
```
