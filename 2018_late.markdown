| Total | Easy | Medium | Hard |
|:---:|:---:|:---:|:---:|
| **6** | 5 | 1 | 0 |


## 2018/12/09

### [119. Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/) `Easy`

> Runtime: 8 ms, faster than 100.00% of Swift online submissions for Pascal's Triangle II.

``` swift
class Solution {
    func getRow(_ rowIndex: Int) -> [Int] {
        if rowIndex == 0 {
            return [1]
        } else if rowIndex == 1 {
            return [1, 1]
        }
        
        var row = [1, 1]
        for index in 2...rowIndex {
            for item in 0...index-2 {
                row[item] = row[item] + row[item+1]
            }
            row.insert(1, at: 0)
        }
        
        return row
    }
}
```

邏輯，從 1,1 到 1,2,1 的過程

```
   [1][1]
    | / 最後一位的 1 保留，總和加到第 0 位 
   [2][1]
   
[1][2][1] // 在前頭加上一個 [1]
```

### [118. Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/submissions/) `Easy`

#### 原本的解法

> Runtime: 12 ms, faster than 22.06% of Swift online submissions for Pascal's Triangle.

很慢又要逐一初始化覺得很不合理！ 的解法

``` swift
class Solution {
    func generate(_ numRows: Int) -> [[Int]] {
        var result = [[Int]](repeating: [], count: numRows)
        for row in (0 ..< numRows) {
            let size = row + 1
            result[row] = [Int](repeating: 0, count: size)
            
            result[row][0] = 1
            result[row][row] = 1
            
            if row > 0 {
                for item in (1..<row) {
                    result[row][item] = result[row-1][item-1] + result[row-1][item]
                }   
            }
        }
        
        return result
    }
}
```

### 討論區的寫法

> Runtime: 8 ms, faster than 100.00% of Swift online submissions for Pascal's Triangle.

- 參考解法： [Swift beats 100%](https://leetcode.com/problems/pascals-triangle/discuss/197394/Swift-beats-100)
- 利用 Swift 的特性，以 append 為主，而非先決定陣列的尺寸再塞資料

``` swift
class Solution {
    func generate(_ numRows: Int) -> [[Int]] {
        var result = [[Int]]()
        var latestRow = [1]
        for row in (0 ..< numRows) {
            var currentRow = [1]
            for item in (0..<latestRow.count-1) {
                currentRow.append(latestRow[item] + latestRow[item+1])
            }
            currentRow.append(1)
            
            result.append(latestRow)
            latestRow = currentRow
        }
        
        return result
    }
}
```

其他解法

- [Swift solution - 100% 8ms - with comments](https://leetcode.com/problems/pascals-triangle/discuss/160630/Swift-solution-100-8ms-with-comments)

## 2018/12/08

### [66. Plus One](https://leetcode.com/problems/plus-one/submissions/) `Easy`

``` swift
class Solution {
    func plusOne(_ digits: [Int]) -> [Int] {
        var result = digits
        var shouldCarry = true
        
        for (index, item) in result.enumerated().reversed() {
            let addition = shouldCarry ? 1 : 0
            let sum = item + addition
            shouldCarry = (sum / 10) != 0
            result[index] = sum % 10
        }
        
        if shouldCarry {
            result.insert(1, at: 0)
        }
        
        return result
    }
}
```

接著想到不需要進位的時候應該是不需要做多餘的運算，所以應該可以改成這樣：

``` swift
class Solution {
    func plusOne(_ digits: [Int]) -> [Int] {
        var result = digits
        var shouldCarry = true
        
        for (index, item) in result.enumerated().reversed() {
            if shouldCarry {
                let sum = result[index] + 1
                shouldCarry = (sum / 10) != 0
                result[index] = sum % 10
            } else {
                shouldCarry = false
            }
        }
        
        if shouldCarry {
            result.insert(1, at: 0)
        }
        
        return result
    }
}
```


#### 碰到的速度上的問題

在反向走訪的地方
一開始沒有用 enumerated 的方式，會慢非常多 (執行時間 `28ms`)

``` swift
for index in (0..<result.count).reversed() {}
```

改成 enumerated 之後，執行速度就變快了 → (執行時間 `12ms`)

``` swift
for (index, item) in result.enumerated().reversed() {}
```

### [80. Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/) `Medium`

``` swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        guard nums.count > 2 else { return nums.count }
        
        var latestPosition = 0
        var appeared = 0
        
        for index in 1..<nums.count {
            if nums[latestPosition] != nums[index] {
                latestPosition += 1
                nums[latestPosition] = nums[index]
                appeared = 0
            } else {
                appeared += 1
                if appeared < 2 {
                    latestPosition += 1
                    nums[latestPosition] = nums[index]
                }
            }
        }
        
        
        return latestPosition + 1
    }
}
```

#### 參考

- https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/discuss/27993/Swift-solution-Two-Pointers

## 2018/12/07

### [27. Remove Element](https://leetcode.com/problems/remove-element/) `Easy`

``` swift
class Solution {
    func removeElement(_ nums: inout [Int], _ val: Int) -> Int {
        guard nums.count > 0 else { return 0 }
        
        var latestPosition = 0
        for index in 0..<nums.count {
            if nums[index] != val {
                nums[latestPosition] = nums[index]
                latestPosition += 1
            }
        }
        
        return latestPosition 
    }
}
```

### [26. Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) `Easy`

``` swift
class Solution {
    func removeDuplicates(_ nums: inout [Int]) -> Int {
        guard nums.count > 0 else { return 0 }
        var latestPosition = 0
        for index in 0..<nums.count {
            if nums[index] != nums[latestPosition] {
                latestPosition += 1
                nums[latestPosition] = nums[index]
            }
        }
        return latestPosition + 1
    }
}
```
